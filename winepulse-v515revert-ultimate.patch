diff --git a/dlls/winepulse.drv/mmdevdrv.c b/dlls/winepulse.drv/mmdevdrv.c
index 417067f0bf8..d816eada24d 100644
--- a/dlls/winepulse.drv/mmdevdrv.c
+++ b/dlls/winepulse.drv/mmdevdrv.c
@@ -68,9 +68,6 @@ enum DriverPriority {
     Priority_Preferred
 };
 
-static const REFERENCE_TIME MinimumPeriod = 30000;
-static const REFERENCE_TIME DefaultPeriod = 100000;
-
 static pa_context *pulse_ctx;
 static pa_mainloop *pulse_ml;
 
@@ -172,16 +169,13 @@ struct ACImpl {
     EDataFlow dataflow;
     DWORD flags;
     AUDCLNT_SHAREMODE share;
-    HANDLE event, timer;
+    HANDLE event;
 
     INT32 locked;
-    UINT32 bufsize_frames, real_bufsize_bytes, period_bytes;
-    UINT32 started, peek_ofs, read_offs_bytes, lcl_offs_bytes, pa_offs_bytes;
-    UINT32 tmp_buffer_bytes, held_bytes, peek_len, peek_buffer_len, pa_held_bytes;
+    UINT32 bufsize_frames, bufsize_bytes, capture_period, pad, started, peek_ofs, wri_offs_bytes, lcl_offs_bytes;
+    UINT32 tmp_buffer_bytes, held_bytes, peek_len, peek_buffer_len;
     BYTE *local_buffer, *tmp_buffer, *peek_buffer;
     void *locked_ptr;
-    BOOL please_quit, just_started, just_underran;
-    pa_usec_t last_time, mmdev_period_usec;
 
     pa_stream *stream;
     pa_sample_spec ss;
@@ -475,9 +469,9 @@ static void pulse_probe_settings(int render, WAVEFORMATEXTENSIBLE *fmt) {
     ss.channels = map.channels;
 
     attr.maxlength = -1;
-    attr.tlength = -1;
-    attr.minreq = attr.fragsize = pa_frame_size(&ss);
-    attr.prebuf = 0;
+    attr.minreq = -1;
+    attr.tlength = attr.fragsize = pa_usec_to_bytes(1000, &ss);
+    attr.prebuf = -1;
 
     stream = pa_stream_new(pulse_ctx, "format test stream", &ss, &map);
     if (stream)
@@ -486,9 +480,9 @@ static void pulse_probe_settings(int render, WAVEFORMATEXTENSIBLE *fmt) {
         ret = -1;
     else if (render)
         ret = pa_stream_connect_playback(stream, NULL, &attr,
-        PA_STREAM_START_CORKED|PA_STREAM_FIX_RATE|PA_STREAM_FIX_CHANNELS|PA_STREAM_EARLY_REQUESTS, NULL, NULL);
+        PA_STREAM_START_CORKED|PA_STREAM_FIX_RATE|PA_STREAM_FIX_CHANNELS|PA_STREAM_EARLY_REQUESTS|PA_STREAM_ADJUST_LATENCY, NULL, NULL);
     else
-        ret = pa_stream_connect_record(stream, NULL, &attr, PA_STREAM_START_CORKED|PA_STREAM_FIX_RATE|PA_STREAM_FIX_CHANNELS|PA_STREAM_EARLY_REQUESTS);
+        ret = pa_stream_connect_record(stream, NULL, &attr, PA_STREAM_START_CORKED|PA_STREAM_FIX_RATE|PA_STREAM_FIX_CHANNELS|PA_STREAM_EARLY_REQUESTS|PA_STREAM_ADJUST_LATENCY);
     if (ret >= 0) {
         while (pa_mainloop_iterate(pulse_ml, 1, &ret) >= 0 &&
                 pa_stream_get_state(stream) == PA_STREAM_CREATING)
@@ -513,12 +507,6 @@ static void pulse_probe_settings(int render, WAVEFORMATEXTENSIBLE *fmt) {
     if (length)
         pulse_def_period[!render] = pulse_min_period[!render] = pa_bytes_to_usec(10 * length, &ss);
 
-    if (pulse_min_period[!render] < MinimumPeriod)
-        pulse_min_period[!render] = MinimumPeriod;
-
-    if (pulse_def_period[!render] < DefaultPeriod)
-        pulse_def_period[!render] = DefaultPeriod;
-
     wfx->wFormatTag = WAVE_FORMAT_EXTENSIBLE;
     wfx->cbSize = sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX);
 
@@ -712,7 +700,18 @@ static void silence_buffer(pa_sample_format_t format, BYTE *buffer, UINT32 bytes
     memset(buffer, format == PA_SAMPLE_U8 ? 0x80 : 0, bytes);
 }
 
-static int write_buffer(const ACImpl *This, BYTE *buffer, UINT32 bytes)
+static void pulse_free_noop(void *buf)
+{
+}
+
+enum write_buffer_flags
+{
+    WINEPULSE_WRITE_NOFREE = 0x01,
+    WINEPULSE_WRITE_SILENT = 0x02
+};
+
+static int write_buffer(const ACImpl *This, BYTE *buffer, UINT32 bytes,
+                        enum write_buffer_flags flags)
 {
     float vol[PA_CHANNELS_MAX];
     BOOL adjust = FALSE;
@@ -720,7 +719,7 @@ static int write_buffer(const ACImpl *This, BYTE *buffer, UINT32 bytes)
     BYTE *end;
 
     if (!bytes) return 0;
-    if (This->session->mute)
+    if (This->session->mute || (flags & WINEPULSE_WRITE_SILENT))
     {
         silence_buffer(This->ss.format, buffer, bytes);
         goto write;
@@ -847,7 +846,9 @@ static int write_buffer(const ACImpl *This, BYTE *buffer, UINT32 bytes)
     }
 
 write:
-    return pa_stream_write(This->stream, buffer, bytes, NULL, 0, PA_SEEK_RELATIVE);
+    return pa_stream_write(This->stream, buffer, bytes,
+                           (flags & WINEPULSE_WRITE_NOFREE) ? pulse_free_noop : NULL,
+                           0, PA_SEEK_RELATIVE);
 }
 
 static void dump_attr(const pa_buffer_attr *attr) {
@@ -870,129 +871,147 @@ static void pulse_attr_update(pa_stream *s, void *user) {
     dump_attr(attr);
 }
 
-static void pulse_write(ACImpl *This)
+/* Here's the buffer setup:
+ *
+ *  vvvvvvvv sent to HW already
+ *          vvvvvvvv in Pulse buffer but rewindable
+ * [dddddddddddddddd] Pulse buffer
+ *         [dddddddddddddddd--------] mmdevapi buffer
+ *          ^^^^^^^^^^^^^^^^ pad
+ *                  ^ lcl_offs_bytes
+ *                  ^^^^^^^^^ held_bytes
+ *                          ^ wri_offs_bytes
+ *
+ * GetCurrentPadding is pad
+ *
+ * During pulse_wr_callback, we decrement pad, fill Pulse buffer, and move
+ *   lcl_offs forward
+ *
+ * During Stop, we flush the Pulse buffer
+ */
+static void pulse_wr_callback(pa_stream *s, size_t bytes, void *userdata)
 {
-    /* write as much data to PA as we can */
-    UINT32 to_write;
-    BYTE *buf = This->local_buffer + This->pa_offs_bytes;
-    UINT32 bytes = pa_stream_writable_size(This->stream);
-
-    if(This->just_underran){
-        /* prebuffer with silence if needed */
-        if(This->pa_held_bytes < bytes){
-            to_write = bytes - This->pa_held_bytes;
-            TRACE("prebuffering %u frames of silence\n",
-                    (int)(to_write / pa_frame_size(&This->ss)));
-            buf = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, to_write);
-            pa_stream_write(This->stream, buf, to_write, NULL, 0, PA_SEEK_RELATIVE);
-            HeapFree(GetProcessHeap(), 0, buf);
+    ACImpl *This = userdata;
+    UINT32 oldpad = This->pad;
+
+    if(This->local_buffer){
+        UINT32 to_write;
+        BYTE *buf = This->local_buffer + This->lcl_offs_bytes;
+
+        if(This->pad > bytes){
+            This->clock_written += bytes;
+            This->pad -= bytes;
+        }else{
+            This->clock_written += This->pad;
+            This->pad = 0;
         }
 
-        This->just_underran = FALSE;
-    }
+        bytes = min(bytes, This->held_bytes);
+
+        if(This->lcl_offs_bytes + bytes > This->bufsize_bytes){
+            to_write = This->bufsize_bytes - This->lcl_offs_bytes;
+            TRACE("writing small chunk of %u bytes\n", to_write);
+            write_buffer(This, buf, to_write, 0);
+            This->held_bytes -= to_write;
+            to_write = bytes - to_write;
+            This->lcl_offs_bytes = 0;
+            buf = This->local_buffer;
+        }else
+            to_write = bytes;
+
+        TRACE("writing main chunk of %u bytes\n", to_write);
+        write_buffer(This, buf, to_write, 0);
+        This->lcl_offs_bytes += to_write;
+        This->lcl_offs_bytes %= This->bufsize_bytes;
+        This->held_bytes -= to_write;
+    }else{
+        if (bytes < This->bufsize_bytes)
+            This->pad = This->bufsize_bytes - bytes;
+        else
+            This->pad = 0;
 
-    buf = This->local_buffer + This->pa_offs_bytes;
-    TRACE("held: %u, avail: %u\n",
-            This->pa_held_bytes, bytes);
-    bytes = min(This->pa_held_bytes, bytes);
-
-    if(This->pa_offs_bytes + bytes > This->real_bufsize_bytes){
-        to_write = This->real_bufsize_bytes - This->pa_offs_bytes;
-        TRACE("writing small chunk of %u bytes\n", to_write);
-        write_buffer(This, buf, to_write);
-        This->pa_held_bytes -= to_write;
-        to_write = bytes - to_write;
-        This->pa_offs_bytes = 0;
-        buf = This->local_buffer;
-    }else
-        to_write = bytes;
+        if (oldpad == This->pad)
+            return;
+
+        assert(oldpad > This->pad);
+
+        This->clock_written += oldpad - This->pad;
+        TRACE("New pad: %zu (-%zu)\n", This->pad / pa_frame_size(&This->ss), (oldpad - This->pad) / pa_frame_size(&This->ss));
+    }
 
-    TRACE("writing main chunk of %u bytes\n", to_write);
-    write_buffer(This, buf, to_write);
-    This->pa_offs_bytes += to_write;
-    This->pa_offs_bytes %= This->real_bufsize_bytes;
-    This->pa_held_bytes -= to_write;
+    if (This->event)
+        SetEvent(This->event);
 }
 
 static void pulse_underflow_callback(pa_stream *s, void *userdata)
+{
+    WARN("Underflow\n");
+}
+
+/* Latency is periodically updated even when nothing is played,
+ * because of PA_STREAM_AUTO_TIMING_UPDATE so use it as timer
+ *
+ * Perfect for passing all tests :)
+ */
+static void pulse_latency_callback(pa_stream *s, void *userdata)
 {
     ACImpl *This = userdata;
-    WARN("%p: Underflow\n", userdata);
-    This->just_underran = TRUE;
-    /* re-sync */
-    This->pa_offs_bytes = This->lcl_offs_bytes;
-    This->pa_held_bytes = This->held_bytes;
+    if (!This->pad && This->event)
+        SetEvent(This->event);
 }
 
 static void pulse_started_callback(pa_stream *s, void *userdata)
 {
-    TRACE("%p: (Re)started playing\n", userdata);
+    TRACE("(Re)started playing\n");
 }
 
-static void pulse_read(ACImpl *This)
+static void pulse_rd_loop(ACImpl *This, size_t bytes)
 {
-    size_t bytes = pa_stream_readable_size(This->stream);
-
-    TRACE("Readable total: %zu, fragsize: %u\n", bytes, pa_stream_get_buffer_attr(This->stream)->fragsize);
-
-    bytes += This->peek_len - This->peek_ofs;
-
-    while (bytes >= This->period_bytes) {
-        BYTE *dst = NULL, *src;
-        size_t src_len, copy, rem = This->period_bytes;
-
-        if (This->started) {
-            LARGE_INTEGER stamp, freq;
-            ACPacket *p, *next;
-
-            if (!(p = (ACPacket*)list_head(&This->packet_free_head))) {
-                p = (ACPacket*)list_head(&This->packet_filled_head);
-                if (!p) return;
-                if (!p->discont) {
-                    next = (ACPacket*)p->entry.next;
-                    next->discont = 1;
-                } else
-                    p = (ACPacket*)list_tail(&This->packet_filled_head);
-            } else {
-                This->held_bytes += This->period_bytes;
-            }
-            QueryPerformanceCounter(&stamp);
-            QueryPerformanceFrequency(&freq);
-            p->qpcpos = (stamp.QuadPart * (INT64)10000000) / freq.QuadPart;
-            p->discont = 0;
-            list_remove(&p->entry);
-            list_add_tail(&This->packet_filled_head, &p->entry);
-
-            dst = p->data;
+    while (bytes >= This->capture_period) {
+        ACPacket *p, *next;
+        LARGE_INTEGER stamp, freq;
+        BYTE *dst, *src;
+        size_t src_len, copy, rem = This->capture_period;
+        if (!(p = (ACPacket*)list_head(&This->packet_free_head))) {
+            p = (ACPacket*)list_head(&This->packet_filled_head);
+            if (!p->discont) {
+                next = (ACPacket*)p->entry.next;
+                next->discont = 1;
+            } else
+                p = (ACPacket*)list_tail(&This->packet_filled_head);
+            assert(This->pad == This->bufsize_bytes);
+        } else {
+            assert(This->pad < This->bufsize_bytes);
+            This->pad += This->capture_period;
+            assert(This->pad <= This->bufsize_bytes);
         }
+        QueryPerformanceCounter(&stamp);
+        QueryPerformanceFrequency(&freq);
+        p->qpcpos = (stamp.QuadPart * (INT64)10000000) / freq.QuadPart;
+        p->discont = 0;
+        list_remove(&p->entry);
+        list_add_tail(&This->packet_filled_head, &p->entry);
 
+        dst = p->data;
         while (rem) {
             if (This->peek_len) {
                 copy = min(rem, This->peek_len - This->peek_ofs);
 
-                if (dst) {
-                    memcpy(dst, This->peek_buffer + This->peek_ofs, copy);
-                    dst += copy;
-                }
+                memcpy(dst, This->peek_buffer + This->peek_ofs, copy);
 
                 rem -= copy;
+                dst += copy;
                 This->peek_ofs += copy;
                 if(This->peek_len == This->peek_ofs)
-                    This->peek_len = This->peek_ofs = 0;
-
-            } else if (pa_stream_peek(This->stream, (const void**)&src, &src_len) == 0 && src_len) {
+                    This->peek_len = 0;
+            } else {
+                pa_stream_peek(This->stream, (const void**)&src, &src_len);
 
                 copy = min(rem, src_len);
 
-                if (dst) {
-                    if(src)
-                        memcpy(dst, src, copy);
-                    else
-                        silence_buffer(This->ss.format, dst, copy);
-
-                    dst += copy;
-                }
+                memcpy(dst, src, rem);
 
+                dst += copy;
                 rem -= copy;
 
                 if (copy < src_len) {
@@ -1002,11 +1021,7 @@ static void pulse_read(ACImpl *This)
                         This->peek_buffer_len = src_len;
                     }
 
-                    if(src)
-                        memcpy(This->peek_buffer, src + copy, src_len - copy);
-                    else
-                        silence_buffer(This->ss.format, This->peek_buffer, src_len - copy);
-
+                    memcpy(This->peek_buffer, src + copy, src_len - copy);
                     This->peek_len = src_len - copy;
                     This->peek_ofs = 0;
                 }
@@ -1015,100 +1030,56 @@ static void pulse_read(ACImpl *This)
             }
         }
 
-        bytes -= This->period_bytes;
+        bytes -= This->capture_period;
     }
 }
 
-static DWORD WINAPI pulse_timer_cb(void *user)
+static void pulse_rd_drop(ACImpl *This, size_t bytes)
 {
-    DWORD delay;
-    UINT32 adv_bytes;
-    ACImpl *This = user;
-    int success;
-    pa_operation *o;
-
-    pthread_mutex_lock(&pulse_lock);
-    delay = This->mmdev_period_usec / 1000;
-    pa_stream_get_time(This->stream, &This->last_time);
-    pthread_mutex_unlock(&pulse_lock);
-
-    while(!This->please_quit){
-        pa_usec_t now, adv_usec = 0;
-        int err;
-
-        Sleep(delay);
-
-        pthread_mutex_lock(&pulse_lock);
-
-        delay = This->mmdev_period_usec / 1000;
-
-        o = pa_stream_update_timing_info(This->stream, pulse_op_cb, &success);
-        if (o)
-        {
-            while (pa_operation_get_state(o) == PA_OPERATION_RUNNING)
-                pthread_cond_wait(&pulse_cond, &pulse_lock);
-            pa_operation_unref(o);
-        }
-        err = pa_stream_get_time(This->stream, &now);
-        if(err == 0){
-            TRACE("got now: %s, last time: %s\n", wine_dbgstr_longlong(now), wine_dbgstr_longlong(This->last_time));
-            if(This->started && (This->dataflow == eCapture || This->held_bytes)){
-                if(This->just_underran){
-                    This->last_time = now;
-                    This->just_started = TRUE;
-                }
-
-                if(This->just_started){
-                    /* let it play out a period to absorb some latency and get accurate timing */
-                    pa_usec_t diff = now - This->last_time;
-
-                    if(diff > This->mmdev_period_usec){
-                        This->just_started = FALSE;
-                        This->last_time = now;
-                    }
-                }else{
-                    INT32 adjust = This->last_time + This->mmdev_period_usec - now;
-
-                    adv_usec = now - This->last_time;
-
-                    if(adjust > ((INT32)(This->mmdev_period_usec / 2)))
-                        adjust = This->mmdev_period_usec / 2;
-                    else if(adjust < -((INT32)(This->mmdev_period_usec / 2)))
-                        adjust = -1 * This->mmdev_period_usec / 2;
-
-                    delay = (This->mmdev_period_usec + adjust) / 1000;
-
-                    This->last_time += This->mmdev_period_usec;
-                }
-
-                if(This->dataflow == eRender){
-                    pulse_write(This);
-
-                    /* regardless of what PA does, advance one period */
-                    adv_bytes = min(This->period_bytes, This->held_bytes);
-                    This->lcl_offs_bytes += adv_bytes;
-                    This->lcl_offs_bytes %= This->real_bufsize_bytes;
-                    This->held_bytes -= adv_bytes;
-                }else if(This->dataflow == eCapture){
-                    pulse_read(This);
-                }
-            }else{
-                This->last_time = now;
-                delay = This->mmdev_period_usec / 1000;
-            }
+    while (bytes >= This->capture_period) {
+        size_t src_len, copy, rem = This->capture_period;
+        while (rem) {
+            const void *src;
+            pa_stream_peek(This->stream, &src, &src_len);
+            assert(src_len);
+            assert(This->peek_ofs < src_len);
+            src_len -= This->peek_ofs;
+            assert(src_len <= bytes);
+
+            copy = rem;
+            if (copy > src_len)
+                copy = src_len;
+
+            src_len -= copy;
+            rem -= copy;
+
+            if (!src_len) {
+                This->peek_ofs = 0;
+                pa_stream_drop(This->stream);
+            } else
+                This->peek_ofs += copy;
+            bytes -= copy;
         }
+    }
+}
 
-        if (This->event)
-            SetEvent(This->event);
+static void pulse_rd_callback(pa_stream *s, size_t bytes, void *userdata)
+{
+    ACImpl *This = userdata;
 
-        TRACE("%p after update, adv usec: %d, held: %u, delay: %u\n",
-                This, (int)adv_usec,
-                (int)(This->held_bytes/ pa_frame_size(&This->ss)), delay);
+    TRACE("Readable total: %zu, fragsize: %u\n", bytes, pa_stream_get_buffer_attr(s)->fragsize);
+    assert(bytes >= This->peek_ofs);
+    bytes -= This->peek_ofs;
+    if (bytes < This->capture_period)
+        return;
 
-        pthread_mutex_unlock(&pulse_lock);
-    }
+    if (This->started)
+        pulse_rd_loop(This, bytes);
+    else
+        pulse_rd_drop(This, bytes);
 
-    return 0;
+    if (This->event)
+        SetEvent(This->event);
 }
 
 static HRESULT pulse_stream_connect(ACImpl *This, UINT32 period_bytes) {
@@ -1137,16 +1108,15 @@ static HRESULT pulse_stream_connect(ACImpl *This, UINT32 period_bytes) {
 
     /* PulseAudio will fill in correct values */
     attr.minreq = attr.fragsize = period_bytes;
-    attr.tlength = period_bytes * 3;
-    attr.maxlength = This->bufsize_frames * pa_frame_size(&This->ss);
+    attr.maxlength = attr.tlength = This->bufsize_bytes;
     attr.prebuf = pa_frame_size(&This->ss);
     dump_attr(&attr);
     if (This->dataflow == eRender)
         ret = pa_stream_connect_playback(This->stream, NULL, &attr,
-        PA_STREAM_START_CORKED|PA_STREAM_START_UNMUTED|PA_STREAM_ADJUST_LATENCY, NULL, NULL);
+        PA_STREAM_START_CORKED|PA_STREAM_START_UNMUTED|PA_STREAM_AUTO_TIMING_UPDATE|PA_STREAM_INTERPOLATE_TIMING|PA_STREAM_EARLY_REQUESTS, NULL, NULL);
     else
         ret = pa_stream_connect_record(This->stream, NULL, &attr,
-        PA_STREAM_START_CORKED|PA_STREAM_START_UNMUTED|PA_STREAM_ADJUST_LATENCY);
+        PA_STREAM_START_CORKED|PA_STREAM_START_UNMUTED|PA_STREAM_AUTO_TIMING_UPDATE|PA_STREAM_INTERPOLATE_TIMING|PA_STREAM_EARLY_REQUESTS);
     if (ret < 0) {
         WARN("Returns %i\n", ret);
         return AUDCLNT_E_ENDPOINT_CREATE_FAILED;
@@ -1157,9 +1127,11 @@ static HRESULT pulse_stream_connect(ACImpl *This, UINT32 period_bytes) {
         return AUDCLNT_E_ENDPOINT_CREATE_FAILED;
 
     if (This->dataflow == eRender) {
+        pa_stream_set_write_callback(This->stream, pulse_wr_callback, This);
         pa_stream_set_underflow_callback(This->stream, pulse_underflow_callback, This);
         pa_stream_set_started_callback(This->stream, pulse_started_callback, This);
-    }
+    } else
+        pa_stream_set_read_callback(This->stream, pulse_rd_callback, This);
     return S_OK;
 }
 
@@ -1297,11 +1269,6 @@ static ULONG WINAPI AudioClient_Release(IAudioClient3 *iface)
     TRACE("(%p) Refcount now %u\n", This, ref);
     if (!ref) {
         if (This->stream) {
-            if(This->timer){
-                This->please_quit = TRUE;
-                WaitForSingleObject(This->timer, INFINITE);
-                CloseHandle(This->timer);
-            }
             pthread_mutex_lock(&pulse_lock);
             if (PA_STREAM_IS_GOOD(pa_stream_get_state(This->stream))) {
                 pa_stream_disconnect(This->stream);
@@ -1597,7 +1564,7 @@ static HRESULT WINAPI AudioClient_Initialize(IAudioClient3 *iface,
 {
     ACImpl *This = impl_from_IAudioClient3(iface);
     HRESULT hr = S_OK;
-    UINT32 bufsize_bytes;
+    UINT period_bytes;
 
     TRACE("(%p)->(%x, %x, %s, %s, %p, %s)\n", This, mode, flags,
           wine_dbgstr_longlong(duration), wine_dbgstr_longlong(period), fmt, debugstr_guid(sessionguid));
@@ -1644,19 +1611,50 @@ static HRESULT WINAPI AudioClient_Initialize(IAudioClient3 *iface,
     if (FAILED(hr))
         goto exit;
 
-    period = pulse_def_period[This->dataflow == eCapture];
-    if (duration < 3 * period)
-        duration = 3 * period;
+    if (mode == AUDCLNT_SHAREMODE_SHARED) {
+        REFERENCE_TIME def = pulse_def_period[This->dataflow == eCapture];
+        REFERENCE_TIME min = pulse_min_period[This->dataflow == eCapture];
 
-    This->period_bytes = pa_frame_size(&This->ss) * MulDiv(period, This->ss.rate, 10000000);
+        /* Switch to low latency mode if below 2 default periods,
+         * which is 20 ms by default, this will increase the amount
+         * of interrupts but allows very low latency. In dsound I
+         * managed to get a total latency of ~8ms, which is well below
+         * default
+         */
+        if (duration < 2 * def)
+            period = min;
+        else
+            period = def;
+        if (duration < 2 * period)
+            duration = 2 * period;
+
+        /* Uh oh, really low latency requested.. */
+        if (duration <= 2 * period)
+            period /= 2;
+
+        const char *duration_env = getenv("STAGING_AUDIO_DURATION");
+        if(duration_env) {
+            int val = atoi(duration_env);
+            duration = val;
+        }
+        const char *period_env = getenv("STAGING_AUDIO_PERIOD");
+        if(period_env) {
+            int val = atoi(period_env);
+            period = val;
+        }
+        printf("duration: %lld; period: %lld\n", duration, period);
+    }
+    period_bytes = pa_frame_size(&This->ss) * MulDiv(period, This->ss.rate, 10000000);
 
-    This->bufsize_frames = ceil((duration / 10000000.) * fmt->nSamplesPerSec);
-    bufsize_bytes = This->bufsize_frames * pa_frame_size(&This->ss);
-    This->mmdev_period_usec = period / 10;
+    if (duration < 20000000)
+        This->bufsize_frames = ceil((duration / 10000000.) * fmt->nSamplesPerSec);
+    else
+        This->bufsize_frames = 2 * fmt->nSamplesPerSec;
+    This->bufsize_bytes = This->bufsize_frames * pa_frame_size(&This->ss);
 
     This->share = mode;
     This->flags = flags;
-    hr = pulse_stream_connect(This, This->period_bytes);
+    hr = pulse_stream_connect(This, period_bytes);
     if (SUCCEEDED(hr)) {
         UINT32 unalign;
         const pa_buffer_attr *attr = pa_stream_get_buffer_attr(This->stream);
@@ -1664,34 +1662,39 @@ static HRESULT WINAPI AudioClient_Initialize(IAudioClient3 *iface,
         /* Update frames according to new size */
         dump_attr(attr);
         if (This->dataflow == eRender) {
-            This->real_bufsize_bytes = This->bufsize_frames * 2 * pa_frame_size(&This->ss);
-            This->local_buffer = HeapAlloc(GetProcessHeap(), 0, This->real_bufsize_bytes);
-            if(!This->local_buffer)
-                hr = E_OUTOFMEMORY;
+            if (attr->tlength < This->bufsize_bytes) {
+                TRACE("PulseAudio buffer too small (%u < %u), using tmp buffer\n", attr->tlength, This->bufsize_bytes);
+
+                This->local_buffer = HeapAlloc(GetProcessHeap(), 0, This->bufsize_bytes);
+                if(!This->local_buffer)
+                    hr = E_OUTOFMEMORY;
+            }
         } else {
             UINT32 i, capture_packets;
 
-            if ((unalign = bufsize_bytes % This->period_bytes))
-                bufsize_bytes += This->period_bytes - unalign;
-            This->bufsize_frames = bufsize_bytes / pa_frame_size(&This->ss);
-            This->real_bufsize_bytes = bufsize_bytes;
+            This->capture_period = period_bytes = attr->fragsize;
+            if ((unalign = This->bufsize_bytes % period_bytes))
+                This->bufsize_bytes += period_bytes - unalign;
+            This->bufsize_frames = This->bufsize_bytes / pa_frame_size(&This->ss);
 
-            capture_packets = This->real_bufsize_bytes / This->period_bytes;
+            capture_packets = This->bufsize_bytes / This->capture_period;
 
-            This->local_buffer = HeapAlloc(GetProcessHeap(), 0, This->real_bufsize_bytes + capture_packets * sizeof(ACPacket));
+            This->local_buffer = HeapAlloc(GetProcessHeap(), 0, This->bufsize_bytes + capture_packets * sizeof(ACPacket));
             if (!This->local_buffer)
                 hr = E_OUTOFMEMORY;
             else {
-                ACPacket *cur_packet = (ACPacket*)((char*)This->local_buffer + This->real_bufsize_bytes);
+                ACPacket *cur_packet = (ACPacket*)((char*)This->local_buffer + This->bufsize_bytes);
                 BYTE *data = This->local_buffer;
-                silence_buffer(This->ss.format, This->local_buffer, This->real_bufsize_bytes);
+                silence_buffer(This->ss.format, This->local_buffer, This->bufsize_bytes);
                 list_init(&This->packet_free_head);
                 list_init(&This->packet_filled_head);
                 for (i = 0; i < capture_packets; ++i, ++cur_packet) {
                     list_add_tail(&This->packet_free_head, &cur_packet->entry);
                     cur_packet->data = data;
-                    data += This->period_bytes;
+                    data += This->capture_period;
                 }
+                assert(!This->capture_period || This->bufsize_bytes == This->capture_period * capture_packets);
+                assert(!capture_packets || data - This->bufsize_bytes == This->local_buffer);
             }
         }
     }
@@ -1756,12 +1759,12 @@ static HRESULT WINAPI AudioClient_GetStreamLatency(IAudioClient3 *iface,
     attr = pa_stream_get_buffer_attr(This->stream);
     if (This->dataflow == eRender){
         lat = attr->minreq / pa_frame_size(&This->ss);
+        lat += pulse_def_period[0];
     }else
         lat = attr->fragsize / pa_frame_size(&This->ss);
     *latency = 10000000;
     *latency *= lat;
     *latency /= This->ss.rate;
-    *latency += pulse_def_period[0];
     pthread_mutex_unlock(&pulse_lock);
     TRACE("Latency: %u ms\n", (DWORD)(*latency / 10000));
     return S_OK;
@@ -1769,7 +1772,7 @@ static HRESULT WINAPI AudioClient_GetStreamLatency(IAudioClient3 *iface,
 
 static void ACImpl_GetRenderPad(ACImpl *This, UINT32 *out)
 {
-    *out = This->held_bytes / pa_frame_size(&This->ss);
+    *out = This->pad / pa_frame_size(&This->ss);
 }
 
 static void ACImpl_GetCapturePad(ACImpl *This, UINT32 *out)
@@ -1781,7 +1784,7 @@ static void ACImpl_GetCapturePad(ACImpl *This, UINT32 *out)
         list_remove(&packet->entry);
     }
     if (out)
-        *out = This->held_bytes / pa_frame_size(&This->ss);
+        *out = This->pad / pa_frame_size(&This->ss);
 }
 
 static HRESULT WINAPI AudioClient_GetCurrentPadding(IAudioClient3 *iface,
@@ -2027,8 +2030,6 @@ static HRESULT WINAPI AudioClient_Start(IAudioClient3 *iface)
         return AUDCLNT_E_NOT_STOPPED;
     }
 
-    pulse_write(This);
-
     if (pa_stream_is_corked(This->stream)) {
         o = pa_stream_cork(This->stream, 0, pulse_op_cb, &success);
         if (o) {
@@ -2043,10 +2044,8 @@ static HRESULT WINAPI AudioClient_Start(IAudioClient3 *iface)
 
     if (SUCCEEDED(hr)) {
         This->started = TRUE;
-        This->just_started = TRUE;
-
-        if(!This->timer)
-            This->timer = CreateThread(NULL, 0, pulse_timer_cb, This, 0, NULL);
+        if (This->dataflow == eRender && This->event)
+            pa_stream_set_latency_update_callback(This->stream, pulse_latency_callback, This);
     }
     pthread_mutex_unlock(&pulse_lock);
     return hr;
@@ -2118,7 +2117,7 @@ static HRESULT WINAPI AudioClient_Reset(IAudioClient3 *iface)
     if (This->dataflow == eRender) {
         /* If there is still data in the render buffer it needs to be removed from the server */
         int success = 0;
-        if (This->held_bytes) {
+        if (This->pad) {
             pa_operation *o = pa_stream_flush(This->stream, pulse_op_cb, &success);
             if (o) {
                 while(pa_operation_get_state(o) == PA_OPERATION_RUNNING)
@@ -2126,14 +2125,14 @@ static HRESULT WINAPI AudioClient_Reset(IAudioClient3 *iface)
                 pa_operation_unref(o);
             }
         }
-        if (success || !This->held_bytes){
-            This->clock_lastpos = This->clock_written = 0;
-            This->pa_offs_bytes = This->lcl_offs_bytes = This->held_bytes = This->pa_held_bytes = 0;
+        if (success || !This->pad){
+            This->clock_lastpos = This->clock_written = This->pad = 0;
+            This->wri_offs_bytes = This->lcl_offs_bytes = This->held_bytes = 0;
         }
     } else {
         ACPacket *p;
-        This->clock_written += This->held_bytes;
-        This->held_bytes = 0;
+        This->clock_written += This->pad;
+        This->pad = 0;
 
         if ((p = This->locked_ptr)) {
             This->locked_ptr = NULL;
@@ -2396,9 +2395,10 @@ static HRESULT WINAPI AudioRenderClient_GetBuffer(IAudioRenderClient *iface,
         UINT32 frames, BYTE **data)
 {
     ACImpl *This = impl_from_IAudioRenderClient(iface);
-    size_t bytes = frames * pa_frame_size(&This->ss);
+    size_t avail, req, bytes = frames * pa_frame_size(&This->ss);
+    UINT32 pad;
     HRESULT hr = S_OK;
-    UINT32 wri_offs_bytes;
+    int ret = -1;
 
     TRACE("(%p)->(%u, %p)\n", This, frames, data);
 
@@ -2417,19 +2417,37 @@ static HRESULT WINAPI AudioRenderClient_GetBuffer(IAudioRenderClient *iface,
         return S_OK;
     }
 
-    if(This->held_bytes / pa_frame_size(&This->ss) + frames > This->bufsize_frames){
+    ACImpl_GetRenderPad(This, &pad);
+    avail = This->bufsize_frames - pad;
+    if (avail < frames || bytes > This->bufsize_bytes) {
         pthread_mutex_unlock(&pulse_lock);
+        WARN("Wanted to write %u, but only %zu available\n", frames, avail);
         return AUDCLNT_E_BUFFER_TOO_LARGE;
     }
 
-    wri_offs_bytes = (This->lcl_offs_bytes + This->held_bytes) % This->real_bufsize_bytes;
-    if(wri_offs_bytes + bytes > This->real_bufsize_bytes){
-        alloc_tmp_buffer(This, bytes);
-        *data = This->tmp_buffer;
-        This->locked = -bytes;
+    if(This->local_buffer){
+        if(This->wri_offs_bytes + bytes > This->bufsize_bytes){
+            alloc_tmp_buffer(This, bytes);
+            *data = This->tmp_buffer;
+            This->locked = -frames;
+        }else{
+            *data = This->local_buffer + This->wri_offs_bytes;
+            This->locked = frames;
+        }
     }else{
-        *data = This->local_buffer + wri_offs_bytes;
-        This->locked = bytes;
+        req = bytes;
+        ret = pa_stream_begin_write(This->stream, &This->locked_ptr, &req);
+        if (ret < 0 || req < bytes) {
+            FIXME("%p Not using pulse locked data: %i %zu/%u %u/%u\n", This, ret, req/pa_frame_size(&This->ss), frames, pad, This->bufsize_frames);
+            if (ret >= 0)
+                pa_stream_cancel_write(This->stream);
+            alloc_tmp_buffer(This, bytes);
+            *data = This->tmp_buffer;
+            This->locked_ptr = NULL;
+        } else
+            *data = This->locked_ptr;
+
+        This->locked = frames;
     }
 
     silence_buffer(This->ss.format, *data, bytes);
@@ -2441,13 +2459,12 @@ static HRESULT WINAPI AudioRenderClient_GetBuffer(IAudioRenderClient *iface,
 
 static void pulse_wrap_buffer(ACImpl *This, BYTE *buffer, UINT32 written_bytes)
 {
-    UINT32 wri_offs_bytes = (This->lcl_offs_bytes + This->held_bytes) % This->real_bufsize_bytes;
-    UINT32 chunk_bytes = This->real_bufsize_bytes - wri_offs_bytes;
+    UINT32 chunk_bytes = This->bufsize_bytes - This->wri_offs_bytes;
 
     if(written_bytes <= chunk_bytes){
-        memcpy(This->local_buffer + wri_offs_bytes, buffer, written_bytes);
+        memcpy(This->local_buffer + This->wri_offs_bytes, buffer, written_bytes);
     }else{
-        memcpy(This->local_buffer + wri_offs_bytes, buffer, chunk_bytes);
+        memcpy(This->local_buffer + This->wri_offs_bytes, buffer, chunk_bytes);
         memcpy(This->local_buffer, buffer + chunk_bytes,
                 written_bytes - chunk_bytes);
     }
@@ -2458,47 +2475,88 @@ static HRESULT WINAPI AudioRenderClient_ReleaseBuffer(
 {
     ACImpl *This = impl_from_IAudioRenderClient(iface);
     UINT32 written_bytes = written_frames * pa_frame_size(&This->ss);
-    BYTE *buffer;
 
     TRACE("(%p)->(%u, %x)\n", This, written_frames, flags);
 
     pthread_mutex_lock(&pulse_lock);
     if (!This->locked || !written_frames) {
+        if (This->locked_ptr)
+            pa_stream_cancel_write(This->stream);
         This->locked = 0;
+        This->locked_ptr = NULL;
         pthread_mutex_unlock(&pulse_lock);
         return written_frames ? AUDCLNT_E_OUT_OF_ORDER : S_OK;
     }
 
-    if(written_frames * pa_frame_size(&This->ss) > (This->locked >= 0 ? This->locked : -This->locked)){
+    if (This->locked < written_frames) {
         pthread_mutex_unlock(&pulse_lock);
         return AUDCLNT_E_INVALID_SIZE;
     }
 
-    if(This->locked >= 0)
-        buffer = This->local_buffer + (This->lcl_offs_bytes + This->held_bytes) % This->real_bufsize_bytes;
-    else
-        buffer = This->tmp_buffer;
+    if(This->local_buffer){
+        BYTE *buffer;
+
+        if(This->locked >= 0)
+            buffer = This->local_buffer + This->wri_offs_bytes;
+        else
+            buffer = This->tmp_buffer;
+
+        if(flags & AUDCLNT_BUFFERFLAGS_SILENT)
+            silence_buffer(This->ss.format, buffer, written_bytes);
+
+        if(This->locked < 0)
+            pulse_wrap_buffer(This, buffer, written_bytes);
+
+        This->wri_offs_bytes += written_bytes;
+        This->wri_offs_bytes %= This->bufsize_bytes;
+
+        This->pad += written_bytes;
+        This->held_bytes += written_bytes;
+
+        if(This->held_bytes == This->pad){
+            int e;
+            UINT32 to_write = min(This->attr.tlength, written_bytes);
 
-    if(flags & AUDCLNT_BUFFERFLAGS_SILENT)
-        silence_buffer(This->ss.format, buffer, written_bytes);
+            /* nothing in PA, so send data immediately */
 
-    if(This->locked < 0)
-        pulse_wrap_buffer(This, buffer, written_bytes);
+            TRACE("pre-writing %u bytes\n", to_write);
 
-    This->held_bytes += written_bytes;
-    This->pa_held_bytes += written_bytes;
-    if(This->pa_held_bytes > This->real_bufsize_bytes){
-        This->pa_offs_bytes += This->pa_held_bytes - This->real_bufsize_bytes;
-        This->pa_offs_bytes %= This->real_bufsize_bytes;
-        This->pa_held_bytes = This->real_bufsize_bytes;
+            e = write_buffer(This, buffer, to_write, 0);
+            if(e)
+                ERR("pa_stream_write failed: 0x%x\n", e);
+
+            This->lcl_offs_bytes += to_write;
+            This->lcl_offs_bytes %= This->bufsize_bytes;
+            This->held_bytes -= to_write;
+        }
+
+    }else{
+        enum write_buffer_flags wr_flags = 0;
+
+        if (flags & AUDCLNT_BUFFERFLAGS_SILENT) wr_flags |= WINEPULSE_WRITE_SILENT;
+        if (!This->locked_ptr) wr_flags |= WINEPULSE_WRITE_NOFREE;
+
+        write_buffer(This, This->locked_ptr ? This->locked_ptr : This->tmp_buffer, written_bytes, wr_flags);
+        This->pad += written_bytes;
+    }
+
+    if (!pa_stream_is_corked(This->stream)) {
+        int success;
+        pa_operation *o;
+        o = pa_stream_trigger(This->stream, pulse_op_cb, &success);
+        if (o) {
+            while(pa_operation_get_state(o) == PA_OPERATION_RUNNING)
+                pthread_cond_wait(&pulse_cond, &pulse_lock);
+            pa_operation_unref(o);
+        }
     }
-    This->clock_written += written_bytes;
-    This->locked = 0;
 
-    TRACE("Released %u, held %zu\n", written_frames, This->held_bytes / pa_frame_size(&This->ss));
+    This->locked = 0;
+    This->locked_ptr = NULL;
+    TRACE("Released %u, pad %zu\n", written_frames, This->pad / pa_frame_size(&This->ss));
+    assert(This->pad <= This->bufsize_bytes);
 
     pthread_mutex_unlock(&pulse_lock);
-
     return S_OK;
 }
 
@@ -2575,13 +2633,13 @@ static HRESULT WINAPI AudioCaptureClient_GetBuffer(IAudioCaptureClient *iface,
 
     ACImpl_GetCapturePad(This, NULL);
     if ((packet = This->locked_ptr)) {
-        *frames = This->period_bytes / pa_frame_size(&This->ss);
+        *frames = This->capture_period / pa_frame_size(&This->ss);
         *flags = 0;
         if (packet->discont)
             *flags |= AUDCLNT_BUFFERFLAGS_DATA_DISCONTINUITY;
         if (devpos) {
             if (packet->discont)
-                *devpos = (This->clock_written + This->period_bytes) / pa_frame_size(&This->ss);
+                *devpos = (This->clock_written + This->capture_period) / pa_frame_size(&This->ss);
             else
                 *devpos = This->clock_written / pa_frame_size(&This->ss);
         }
@@ -2615,11 +2673,11 @@ static HRESULT WINAPI AudioCaptureClient_ReleaseBuffer(
     if (done) {
         ACPacket *packet = This->locked_ptr;
         This->locked_ptr = NULL;
-        This->held_bytes -= This->period_bytes;
+        This->pad -= This->capture_period;
         if (packet->discont)
-            This->clock_written += 2 * This->period_bytes;
+            This->clock_written += 2 * This->capture_period;
         else
-            This->clock_written += This->period_bytes;
+            This->clock_written += This->capture_period;
         list_add_tail(&This->packet_free_head, &packet->entry);
     }
     This->locked = 0;
@@ -2639,7 +2697,7 @@ static HRESULT WINAPI AudioCaptureClient_GetNextPacketSize(
     pthread_mutex_lock(&pulse_lock);
     ACImpl_GetCapturePad(This, NULL);
     if (This->locked_ptr)
-        *frames = This->period_bytes / pa_frame_size(&This->ss);
+        *frames = This->capture_period / pa_frame_size(&This->ss);
     else
         *frames = 0;
     pthread_mutex_unlock(&pulse_lock);
@@ -2731,7 +2789,7 @@ static HRESULT WINAPI AudioClock_GetPosition(IAudioClock *iface, UINT64 *pos,
         return hr;
     }
 
-    *pos = This->clock_written - This->held_bytes;
+    *pos = This->clock_written;
 
     if (This->share == AUDCLNT_SHAREMODE_EXCLUSIVE)
         *pos /= pa_frame_size(&This->ss);
         pulse_def_period[!render] = pulse_min_period[!render] = pa_bytes_to_usec(10 * length, &ss);
 
-    if (pulse_min_period[!render] < MinimumPeriod)
-        pulse_min_period[!render] = MinimumPeriod;
-
-    if (pulse_def_period[!render] < DefaultPeriod)
-        pulse_def_period[!render] = DefaultPeriod;
-
     wfx->wFormatTag = WAVE_FORMAT_EXTENSIBLE;
     wfx->cbSize = sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX);
 
@@ -1135,11 +1129,19 @@ static HRESULT pulse_stream_connect(ACImpl *This, UINT32 period_bytes) {
     pa_stream_set_buffer_attr_callback(This->stream, pulse_attr_update, This);
     pa_stream_set_moved_callback(This->stream, pulse_attr_update, This);
 
-    /* PulseAudio will fill in correct values */
-    attr.minreq = attr.fragsize = period_bytes;
-    attr.tlength = period_bytes * 3;
-    attr.maxlength = This->bufsize_frames * pa_frame_size(&This->ss);
-    attr.prebuf = pa_frame_size(&This->ss);
+    attr.minreq = 16;
+    attr.prebuf = 8;
+    const char* tenv = getenv("STAGING_TLENGTH_USEC");
+    if (tenv) {
+        int val = atoi(tenv);
+        attr.maxlength               = pa_usec_to_bytes(val * 4, &This->ss);
+        attr.tlength = attr.fragsize = pa_usec_to_bytes(val, &This->ss);
+        printf("Pulse tlength/fragsize set to %d.\n", attr.tlength);
+    } else {
+        attr.maxlength               = pa_usec_to_bytes(10000, &This->ss);
+        attr.tlength = attr.fragsize = period_bytes * 3;
+        printf("Pulse tlength/fragsize KEPT at %d.\n", attr.tlength);
+    }
     dump_attr(&attr);
     if (This->dataflow == eRender)
         ret = pa_stream_connect_playback(This->stream, NULL, &attr,

@@ -2414,8 +2414,10 @@ static HRESULT WINAPI AudioClient_Start(IAudioClient3 *iface)
         This->started = TRUE;
         This->just_started = TRUE;
 
-        if(!This->timer)
+        if(!This->timer) {
             This->timer = CreateThread(NULL, 0, pulse_timer_cb, This, 0, NULL);
+            SetThreadPriority(This->timer, THREAD_PRIORITY_TIME_CRITICAL);
+        }
     }
     pthread_mutex_unlock(&pulse_lock);
     return hr;
-- 
2.30.1

@@ -38,6 +38,7 @@
 #include "winbase.h"
 #include "winnls.h"
 #include "winreg.h"
+#include "winternl.h"
 #include "wine/debug.h"
 #include "wine/unicode.h"
 #include "wine/list.h"
@@ -1308,14 +1309,14 @@ static void pulse_read(ACImpl *This)
 
 static DWORD WINAPI pulse_timer_cb(void *user)
 {
-    DWORD delay;
+    LARGE_INTEGER delay;
     UINT32 adv_bytes;
     ACImpl *This = user;
     int success;
     pa_operation *o;
 
     pthread_mutex_lock(&pulse_lock);
-    delay = This->mmdev_period_usec / 1000;
+    delay.QuadPart = -This->mmdev_period_usec * 10;
     pa_stream_get_time(This->stream, &This->last_time);
     pthread_mutex_unlock(&pulse_lock);
 
@@ -1323,11 +1324,11 @@ static DWORD WINAPI pulse_timer_cb(void *user)
         pa_usec_t now, adv_usec = 0;
         int err;
 
-        Sleep(delay);
+        NtDelayExecution(FALSE, &delay);
 
         pthread_mutex_lock(&pulse_lock);
 
-        delay = This->mmdev_period_usec / 1000;
+        delay.QuadPart = -This->mmdev_period_usec * 10;
 
         o = pa_stream_update_timing_info(This->stream, pulse_op_cb, &success);
         if (o)
@@ -1363,7 +1364,7 @@ static DWORD WINAPI pulse_timer_cb(void *user)
                     else if(adjust < -((INT32)(This->mmdev_period_usec / 2)))
                         adjust = -1 * This->mmdev_period_usec / 2;
 
-                    delay = (This->mmdev_period_usec + adjust) / 1000;
+                    delay.QuadPart = -(This->mmdev_period_usec + adjust) * 10;
 
                     This->last_time += This->mmdev_period_usec;
                 }
@@ -1381,16 +1382,16 @@ static DWORD WINAPI pulse_timer_cb(void *user)
                 }
             }else{
                 This->last_time = now;
-                delay = This->mmdev_period_usec / 1000;
+                delay.QuadPart = -This->mmdev_period_usec * 10;
             }
         }
 
         if (This->event)
             SetEvent(This->event);
 
-        TRACE("%p after update, adv usec: %d, held: %u, delay: %u\n",
+        TRACE("%p after update, adv usec: %d, held: %u, delay usec: %u\n",
                 This, (int)adv_usec,
-                (int)(This->held_bytes/ pa_frame_size(&This->ss)), delay);
+                (int)(This->held_bytes/ pa_frame_size(&This->ss)), -delay.QuadPart / 10);
 
         pthread_mutex_unlock(&pulse_lock);
     }
-- 
2.30.1

@@ -68,9 +68,6 @@ enum DriverPriority {
     Priority_Preferred
 };
 
-static const REFERENCE_TIME MinimumPeriod = 30000;
-static const REFERENCE_TIME DefaultPeriod = 100000;
-
 static pa_context *pulse_ctx;
 static pa_mainloop *pulse_ml;
 
@@ -510,14 +507,14 @@ static void pulse_probe_settings(int render, WAVEFORMATEXTENSIBLE *fmt) {
     if (stream)
         pa_stream_unref(stream);
 
-    if (length)
+    if (length) {
         pulse_def_period[!render] = pulse_min_period[!render] = pa_bytes_to_usec(10 * length, &ss);
-
-    if (pulse_min_period[!render] < MinimumPeriod)
-        pulse_min_period[!render] = MinimumPeriod;
-
-    if (pulse_def_period[!render] < DefaultPeriod)
-        pulse_def_period[!render] = DefaultPeriod;
+        printf("Using length '%lld' returned from PA\n", length);
+    } else {
+        int default_us = 333;
+        pulse_def_period[!render] = pulse_min_period[!render] = pa_usec_to_bytes(default_us, &ss);
+        printf("Using default length '%lld' (%lld us)\n", length, default_us);
+    }
 
     wfx->wFormatTag = WAVE_FORMAT_EXTENSIBLE;
     wfx->cbSize = sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX);
@@ -1645,9 +1642,23 @@ static HRESULT WINAPI AudioClient_Initialize(IAudioClient3 *iface,
         goto exit;
 
     period = pulse_def_period[This->dataflow == eCapture];
+    const char *duration_env = getenv("STAGING_AUDIO_DURATION");
+    if (duration_env) {
+        int val = atoi(duration_env);
+        if (val == 0) {
+            printf("ignoring duration: %lld requested by program; using duration: %lld\n", duration, 3 * period);
+            duration = 3 * period;
+        } else {
+            printf("duration overwritten: %lld\n", val);
+            duration = val;
+        }
+    }
+
     if (duration < 3 * period)
         duration = 3 * period;
 
+    printf("duration: %lld; period: %lld\n", duration, period);
+
     This->period_bytes = pa_frame_size(&This->ss) * MulDiv(period, This->ss.rate, 10000000);
 
     This->bufsize_frames = ceil((duration / 10000000.) * fmt->nSamplesPerSec);
